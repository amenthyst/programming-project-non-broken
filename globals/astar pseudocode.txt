function AStar(start: Vector2, end: Vector2) -> Vector2[]:
	// this pseudocode does not include anything about initializing the nodes and computing g and h
	// it assumes all the attributes of the node are ready
	struct Node:
	   int g = distance from start node
	   int h = distance from end node // heuristic
	   int f = g + h 
	   bool walkable
	   Vector2 vector

	function tracePath(parents: Dict<Node, Node>, current: Node) -> Vector2[]:
		// helper function, constructs the whole path from the end node and its parents
		// parents is a map recording what node (child) came from what node (parent)
		// by traversing this map, this function can recover the whole path from each node's
		// successive parent.
		path: List<Node> = {current}
		while current in parents.Keys():
			current = parents[current]
			path.prepend(current)
		return path

	openSet: PriorityQueue<Node, int> = {start} // list of nodes to be evaluated, priority queue
	closedSet: List<Node> = {} // list of nodes already evaluated

	parents = new Dict<Node, Node> 
	// for use in tracing the path, the nodes in the path will be 
	// recorded here like a linked list

	while openSet is not empty:
		currentNode = node in openSet with lowest f value
		if currentNode.vector == end:
			return tracePath(parents, currentNode)

		openSet.remove(currentNode)
		closedSet.append(currentNode)

		neighbours: Node[] = getNeighbours(Node)

		for neighbour in neighbours:
			if neighbour in closedSet or neighbour.walkable == false:
				continue
			
			distanceFromStartToNeighbour = current.g + distance from current to neighbour

			if distanceFromStartToNeighbour < neighbour.g:
				// this node is part of the shortest path, record it
				current = parents[neighbour] // set parent of neighbour to current, for tracePath
				update f value of neighbour
				if neighbour not in openSet:
					add neighbour to openSet
	return failure/error

// sqrt(2) = 1.4
// all costs are times 10 to make it an int
function heuristic(node):
	dx = abs(node.x-goal.x)
	dy = abs(node.y-goal.y)
	return 10 * (dx+dy) - (14 - 2 * 10) * min(dx, dy)



function GetTileMapData() -> Dictionary<Key: Vector2I[], Value: Node>:
	groundTiles = groundTileMap.GetUsedCells()
	obstacleTiles = obstacleTileMap.GetUsedCells()
	dict = new Dictionary<Key: Vector2I[], Value: Node>
	for coords in groundTiles:
		if coords in obstacleTiles:
			initialise Node with walkable = false
		else:
			initialise Node with walkable = true
		append Node to dict with key coords
	return dict

function printTileMapData():
	// assumes x and y are integers and equal or more than 0.

	Node[,] tileArray = new 2D Array 
	string arrayString = ""

	for key in nodeDict.keys:
		tileArray[key.y, key,x] = nodeDict[key]

	for row in tileArray:
		for col in row:
			if tileArray[row, col].walkable == false:
				arrayString += '#' 
			else:
				arrayString += '.'
		arrayString += "\n"
	return arrayString

function lazyGetNode(globalCoords, currentNode, targetNode) -> KeyValuePair of key Vector2 and value PathfindingNode:
	Vector2I position = GlobaltoMap(globalCoords)
	if position in obstacleLayerCoords:
		initialize node with walkable = false and node.position = MaptoGlobal(position)
	else:
		initialize node with walkable = true and node.position = MaptoGlobal(position)
	node.g = CalcGCost(node.position, currentNode.position)
	node.h = Heuristic(node.position. targetNode.position)
	return KeyValuePair(MaptoGlobal(position), node)
	// after this function add the keyvaluepair to a dictionary

function lineOfSightSmoothPath(path: Vector2):
	smoothedPath = [path[0]] (list of vector2)
	Raycast2D rayCast = new()
	apex_index = 0
	i = 1
	while i < path.length:
		apex = path[apex_index]
		target = path[i]
		if (!rayCast.hit_any_obstacles(apex, target)):
			i += 1
			continue
		else:
			# it hit an obstacle, index of 
			apex_index = i - 1
			smoothedPath.append(path[apex_index])
			i = apex_index + 1
	
	if path[path.length - 1] not in smoothedPath
		smoothedPath.append(path[path.length - 1])
	return smoothedPath

function addAgentRadius(path):
	newPath = []
	for vec in path:
		offset = new Vector2
		for dir in neighbourDirections:
			if node at (vec + dir) is not walkable
				offset += opposite(dir) * agentRadius 
		vec += offset
		newPath.append(vec)
	return newPath

function parseGridIntoIslands():
	dirs = [left vector, right vector, up vector, down vector]
	localArray = walkableGrid.copy()
	islands = new list of hashset<Vector2I>
	currentIsland = hashset<Vector2I>
	function depthFirstSearch(pos):
		// recursive.
		currentIsland.Add(pos)
		localArray[pos] = null // modifies the array
		for dir in dirs:
			offset = pos + dir
			if offset in bounds of array and localArray[offset] == true:
				depthFirstSearch(offset)
	
	for row in localArray:
		for col in row:
			if localArray[row, col] == true:
				depthFirstSearch[Vector2I(row, col)]
				islands.Add(currentIsland)
				currentIsland.clear()
	
	return islands

class Window:
	int xmin;
	int xmax;
	int ymin;
	int ymax;

function ParseObstaclesIntoRectangles():
	for obstacleSet in obstacles:
		obstacles[obstacleSet.index] = obstacleSet.ToArray()
	List<Window> windows = new();
	for obstacleSet in obstacle:
		Window window = new();
		window.xmin = obstacleSet[0]'s collider's top left corner X coordinate
		window.xmax = obstacleSet[^1]'s collider's top right corner X coordinate
		window.ymin = obstacleSet[0]'s collider's bottom left corner Y coordinate
		window.xmax = obstacleSet[^1]'s collider's top right corner Y coordinate
		windows.append(window)
	return windows.ToArray()

function LiangBarskyEntersRectangle(start, end, window):
	x1 = start.x
	x2 = end.X
	y1 = start.Y
	y2 = end.Y
	dx = x2-x1
	dy = y2-y1
	p = [-dx, dx, -dy, dy]
	q = [x1 - window.xmin, window.xmax - x1, y1 - window.ymin, window.ymax - y1]
	t_enter = 0
	t_exit = 1
	for i in range(4):
		if p[i] == 0:
			// the line is parallel - either horizontal or vertical
			if q[i] < 0:
			// line outside rectangle 
			return false
		else:
				t = q[i] / p[i]
				if p[i] < 0:
					if t > t_enter:
						t_enter = t
				else:
					if t < t_exit:
						t_exit = t
	if t_enter > t_exit:
		return false // line outside rectangle
	else:
		return true

dx = x2-x1
dy = y2-y1
		
X = x1 + t(dx)
Y = y1 + t(dy)

0 <= t <= 1

these inequalities must be true if a line intersects the window:
window xmin <= X <= window xmax
window ymin <= Y <= window ymax

rearranged as:
t(dx) >= xmin - x1
t(dx) <= xmax - x1
t(dy) >= ymin - y1
t(dy) <= ymax - y1

then:
-t(dx) <= x1 - xmin
t(dx) <= xmax - x1
-t(dy) <= y1 - ymin
t(dy) <= ymax - y1

function AddBezierCurving(Vector2[] pathGlobal) {
	newpath = list<vector2>

	foreach item in pathGlobal starting from index 1 and ending at index pathGlobal.length-2:
		newpath.append(pathGlobal[i-1])
		// setting control points of quadratic bezier
		point1 = vector2 distance (setDistance) away from pathGlobal[i] in direction (pathGlobal[i]-pathGlobal[i-1])
		point3 = vector2 distance (setDistance) away from pathGlobal[i] in direction (pathGlobal[i+1]-pathGlobal[i])
		point2 = vector2 distance (controlPoint distance) away from pathGlobal[i] in direction (perpendicular of direction point1 and point3)

		for i from 1 to curve_resolution:
			curvePoint = sample bezier point with control points point1, point2, point3 and with t = i / curve_resolution
			newPath.append(curvePoint)

	newPath.append(last point of pathGlobal)
	return newPath
	
}
